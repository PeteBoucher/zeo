<!doctype html>
<html>
<head>
<script>
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

const _render = (src, width, height) => new Promise((accept, reject) => {
  const xmlSrc = (() => {
    const el = document.createElement('div');
    el.setAttribute('style', rootCss);
    el.innerHTML = src;
    return new XMLSerializer().serializeToString(el);
  })();
  const cleanSrc = xmlSrc
    .replace(/([^\x00-\x7F])/g, (all, c) => ('&#' + c.charCodeAt(0) + ';')) // convert non-ascii to HTML entities
    .replace(/#/g, '%23'); // firefox gets confused if we don't escape hashes in the data url
  const wrappedSrc = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '">' +
    '<foreignObject width="100%" height="100%" x="0" y="0">' +
      cleanSrc +
    '</foreignObject>' +
  '</svg>';

  const img = new Image();
  img.src = wrappedSrc;
  img.onload = () => {
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    const dataUrl = canvas.toDataURL('image/png');
    fetch(dataUrl)
      .then(res => res.arrayBuffer())
      .then(accept)
      .catch(reject);
  };
  img.onerror = err => {
    console.warn(err);
  };

});

fetch('/archae/signal/2')
  .then(res => res.json())
  .then(({description, iceCandidates}) => {
    const c = new RTCPeerConnection({
      iceServers: [
        {urls:'stun:stun.l.google.com:19302'},
        // {urls:'stun:stun1.l.google.com:19302'},
        // {urls:'stun:stun2.l.google.com:19302'},
        // {urls:'stun:stun3.l.google.com:19302'},
        // {urls:'stun:stun4.l.google.com:19302'},
      ],
    });
    c.setRemoteDescription(description);
    for (let i = 0; i < iceCandidates.length; i++) {
      const iceCandidate = iceCandidates[i];
      c.addIceCandidate(iceCandidate);
    }

    return c.createAnswer()
      .then(description => new Promise((accept, reject) => {
        c.setLocalDescription(description);
        const iceCandidates = [];
        c.onicecandidate = e => {
          iceCandidates.push(e.candidate);
        };
        c.onicegatheringstatechange = () => {
          if (c.iceGatheringState === 'complete') {
            const jsonHeaders = new Headers();
            jsonHeaders.append('Content-Type', 'application/json');
            fetch('/archae/signal/3', {
              method: 'POST',
              headers: jsonHeaders,
              body: JSON.stringify({
                description,
                iceCandidates,
              }),
            })
              .then(res => res.json())
              .then(accept)
              .catch(reject);

            c.ondatachannel = e => {
              const d = e.channel;
              d.onmessage = e => {
                const {data} = e;
                const match = data.match(/^\[([0-9]+),([0-9]+)\]/);
                const width = parseInt(match[1], 10);
                const height = parseInt(match[2], 10);
                const src = data.slice(match[0].length);
                _render(src, width, height)
                  .then(buffer => {
                    d.send(buffer);
                  })
                  .catch(err => {
                    console.warn(err);
                  });
              };
            };

            c.onicecandidate = null;
            c.onicegatheringstatechange = null;
          }
        };
      }));
  })
  .catch(err => {
    console.warn(err);
  });

const fonts = `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
const monospaceFonts = `Consolas, "Liberation Mono", Menlo, Courier, monospace`;
const fontWeight = 300;
const fontStyle = 'normal';
const rootCss = `margin: 0px; padding: 0px; height: 100%; width: 100%; font-family: ${fonts}; font-weight: ${fontWeight}; overflow: visible; user-select: none;`;
</script>
</head>
<body>
render process -- do not close this window!
</body>
</html>
